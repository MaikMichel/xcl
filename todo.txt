TODO:

    DEFAULTS
    - Global defaults haben kein projekt und landen in der environment.yaml
    - Projekt defaults haben ein projekt und landen in der environment_projectName.yaml
    - Reihenfolge der Auswertung:
        1. Befehl
        2. Projektumgebung
        3. Global
    => DONE

    - Vergleiche Status mit Config                                                    (plan)
        * local-Status wird nicht in die Versionskontrolle aufgenommen sondern liegt
          im lokalen Install-Verzeichnis, oder ist in der gitignore
          GRUND: Eine der Dateien muss die Führende sein, imo, die xcl.yaml
                GRUND: Weil die xcl.yaml in der Versionskontrolle ist
    => DONE

    - Ableiten der notwendigen Befehle um Ziel auf den beschriebenen Stand zu bringen (plan)
        * Ableitung schreibt befehle in eine pseudo sh-Datei
        * es werden auch wieder xcl oder sql verwendet
        * GRUND: Es bleibt konsistent und erzeugen des lokalen Status-File
        * VORSCHLAG: Falls sys gebraucht wird, wird das passwort als Variable eingelesen und am ende wieder resettet
    => DONE

    - Ausführen der Befehle                                                           (apply)
        * Erst hier wird das lokale Status - File geschrieben
        * Nachdem die Installation der Dependencies, Schemas und Applikationen erfolgreich war
    => DONE

    - Einspielen des aktuellen Projektstands                                          (deploy)
        * Ein Entwickler pusht Änderungen, die vom Rest des Teams gepullt werden
        * Update nimmt den Code-Stand und spielt diesen auf der lokalen umgebung ein
        * Die Änderungen werden nur für APP, LOGIC, DATA gemacht + APEX Applikation
        * Kann auch manuell ausgeführt werden, wenn sich aber die xcl.yaml ändert muss plan / apply gemacht werden
    => DONE

    - Passwort für Benutzer generieren @JAW
    => DONE

    - Multi Application Support?

    - Upgrade Funktion:
        * Wenn sich dinge in der DirectoryStruktur ändern, sollte xcl automatisch die Änderungen vornehmen können,
          solange, die Ordner nicht mit Dateien befüllt sind. Ansonsten sollte eine Hilfe-Meldung ausgegeben werden
        * Es werden nur Ordner hinzugefügt nicht gelöscht!
    => DONE



    - LOGGING-Klasse schreiben:
        * damit die Logs während des Deploys weggeschrieben werden brauchen wir eine Logging-Klasse!
        * DER DB-HELPER loggt im moment nichts weg! Nach dem apply ist man blind!

    - PROBLEME:
        * Ein Feature wird entfernt
            GRUND: Plan kann zwar erkennen, dass das Feature entfernt wurde, kennt aber den Benutzer nicht mehr unter dem es installiert wurde
                   Deswegen kann der Befehl zum entfernen des Features nicht generiert werden.
            MÖGLICHER WORKAROUND: Schema Only Accounts (erst ab 18c)
            MÖGLICHE LÖSUNG: Status file bekommt auch das schema und das passwort mit damit Features deinstalliert werden können


    - DBFLOW: @MMI
        * Implementieren der Build Funktionen
        * Implementieren der Deploy Funktionen

    - AutoApply: @JAW
        * xcl project:plan --auto --yes
    =>DONE

    - Bug in apply @JAW
        * Hier wird der Hash nicht sauber weggeschrieben
    =>DONE

    - Projekt init aufräumen @JAW
    =>DONE?

    - SingleSchema @JAW
    =>DONE

    - Project create mit Wizard @MMI

    - Deploy Method für welche xcl-Version?
        * Warum: Wenn sich dinge in der Ordnerstruktur ändern, muss auch die deploy Methode angeglichen werden
        * Um kompatibilität zu gewähren muss die deploy feature version zur xcl version passen
    => Wird nicht gelöst

    - Dateien werden zu setup hinzugefügt, aber lokal wird nie ein plan/apply ausgeführt, sodass
      die Dateien nicht im setup array von der xcl.yml landen. Im jenkins bemerkt xcl aber die Änderungen
      und führt ab jetzt jedes mal ein plan/apply lauf aus
        => Entscheidung: Setup-Array aus xcl.yml entfernen
        
    - Liquibase für XCL - Wie bringt man liquibase hooks bei?
    => wird nicht gelöst

    - xcl features:... 
      features müssen vielleicht nur einmal installiert werden, können danach aber an mehrere schemata gegranted werden
      viele features haben dafür eigene granting skripte, die müssen ausgeführt werden auch wenn das feature bereits installiert ist
      Idee: ein Flag in der software.yml die ein skript als always execute markiert, diese skripte bei installation des features immer ausgeführt 
    
    - Unterschiedliche Versionsnummern in n Applikationen
    
    - Individuelle Features:
      features die z.B. inhouse entwickelt wurden oder, die nicht openSource bei github geladen werden können (Beispiel AOP),
      möglichkeit anbieten, diese ebenfalls in das Projekt mitaufnehmen zu können
      kleiner wizzard, wo liegt das zip-File für das feature, wie heißt das install skript
      add feature arbeitet dann genauso wie vorher, möglich in ein seperates Schema zu installieren oder in ein "Projekt-Schema"

    - Name für die Ordnerstruktur finden
    
    - Deploy schlägt fehl -> gradle build failed return value?